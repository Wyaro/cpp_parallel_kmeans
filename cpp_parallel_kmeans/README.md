# C++ K-Means с CUDA

Реализация алгоритма K-means на C++ с использованием CUDA, аналогичная Python версии из `py-parallel-kmeans-main`.

## Структура проекта

```
cpp_parallel_kmeans/
├── include/              # Заголовочные файлы
│   ├── dataset.h         # Класс для загрузки данных
│   ├── kmeans_base.h     # Базовый класс для реализаций K-means
│   ├── kmeans_cuda.h     # Заголовок CUDA реализаций
│   └── timer.h           # Высокоточные таймеры
├── src/                  # Исходные файлы
│   ├── dataset.cpp       # Реализация загрузки данных
│   ├── kmeans_base.cpp   # Реализация базового класса
│   └── kmeans_cuda.cu    # CUDA реализации (V1 и V2)
├── main.cpp              # Основной файл для запуска
├── README.md             # Документация
└── cpp_parallel_kmeans.vcxproj  # Файл проекта Visual Studio
```

## Требования

- Visual Studio 2019 или новее
- CUDA Toolkit 11.0 или новее
- NVIDIA GPU с поддержкой CUDA
- Windows 10/11 (x64)

## Настройка проекта

1. Убедитесь, что CUDA Toolkit установлен и переменная окружения `CUDA_PATH` установлена.

2. Откройте проект в Visual Studio.

3. В свойствах проекта убедитесь, что:
   - Платформа: x64
   - Язык стандарта C++: C++20
   - CUDA включен в настройках проекта

4. Если CUDA не обнаружен автоматически, добавьте вручную:
   - **Additional Include Directories**: `$(CUDA_PATH)\include`
   - **Additional Library Directories**: `$(CUDA_PATH)\lib\x64`
   - **Additional Dependencies**: `cudart.lib`

## Компиляция

1. Выберите конфигурацию (Debug или Release) и платформу x64
2. Соберите проект (Build → Build Solution)

## Использование

```bash
cpp_parallel_kmeans.exe <dataset_path> [version]
```

Параметры:
- `dataset_path` - путь к файлу датасета (например, `..\datasets\base\N100000_D50_K8.txt`)
- `version` - версия CUDA реализации (1 или 2, по умолчанию 1)

Пример:
```bash
cpp_parallel_kmeans.exe ..\datasets\base\N100000_D50_K8.txt 1
```

## Версии CUDA реализаций

### V1 - Базовая версия
- Прямое вычисление расстояний через broadcasting
- Использует O(N × K × D) памяти для временных массивов
- Подходит для небольших и средних датасетов

### V2 - Оптимизированная версия
- Использует матричную формулу `||x||² + ||c||² - 2x·c` без материализации diff
- Требует O(N × K) памяти вместо O(N × K × D)
- Быстрее V1 за счет оптимизированного assign

## Формат данных

Датасеты должны быть в формате, созданном Python генератором:
- Первая строка: JSON метаданные (начинается с `#`)
- Следующие K строк: центроиды (метка + координаты)
- Пустая строка
- Следующие N строк: точки данных (метка + координаты)

## Метрики производительности

Программа выводит следующие метрики:
- `T_assign_total` - общее время шага назначения (секунды)
- `T_update_total` - общее время шага обновления (секунды)
- `T_iter_total` - общее время всех итераций (секунды)
- `T_assign_avg` - среднее время шага назначения на итерацию
- `T_update_avg` - среднее время шага обновления на итерацию
- `T_iter_avg` - среднее время одной итерации

## Примечания

- Алгоритм останавливается при сходимости (изменение центроидов < tol) или после максимального количества итераций (100)
- Порог сходимости по умолчанию: 1e-6
- Для пустых кластеров сохраняются старые центроиды

